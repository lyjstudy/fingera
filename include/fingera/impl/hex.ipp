#pragma once

namespace fingera {


namespace hex_detail {

static constexpr const char HEX_STRING_LOWER[16] = {
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
};
static constexpr const char HEX_STRING_UPPER[16] = {
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
};

static constexpr const uint8_t HEX_MAP[256] = {
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0,1,2,3,4,5,6,7,8,9,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xa,0xb,0xc,0xd,0xe,0xf,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xa,0xb,0xc,0xd,0xe,0xf,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
};

} // namespace hex_detail;

template<typename IteratorIn, typename IteratorOut, bool IsLower>
void to_hex(IteratorIn begin, IteratorIn end, IteratorOut out) {
    for (IteratorIn i = begin; i != end; i++) {
        uint8_t b = *i;
        if (IsLower) {
            *out++ = hex_detail::HEX_STRING_LOWER[b >> 4];
            *out++ = hex_detail::HEX_STRING_LOWER[b & 0xF];
        } else {
            *out++ = hex_detail::HEX_STRING_UPPER[b >> 4];
            *out++ = hex_detail::HEX_STRING_UPPER[b & 0xF];
        }
    }
}

template<bool IsLower>
inline void to_hex(const void *buf, char *str, size_t byte_size) {
    const uint8_t *bytes = reinterpret_cast<const uint8_t  *>(buf);
    to_hex<const uint8_t *, char *, IsLower>(bytes, bytes + byte_size, str);
}

template<bool IsLower>
inline std::string to_hex(const void *buf, size_t byte_size) {
    std::string ret;
    ret.resize(byte_size * 2);
    to_hex<IsLower>(buf, const_cast<char *>(ret.c_str()), byte_size);
    return std::move(ret);
}

template<typename Iterator, bool IsLower>
inline std::string to_hex(Iterator begin, Iterator end) {
    std::string ret;
    ret.resize((end - begin) * 2);
    to_hex<Iterator, char *, IsLower>(begin, end, const_cast<char *>(ret.c_str()));
    return std::move(ret);
}

template<typename Container, bool IsLower>
inline std::string to_hex(const Container &container) {
    return to_hex<decltype(container.begin()), IsLower>(container.begin(), container.end());
}

template<typename IteratorIn, typename IteratorOut>
bool from_hex(IteratorIn begin, IteratorIn end, IteratorOut out) {
    if ((end - begin) % 2 != 0) {
        return false;
    }
    for (IteratorIn i = begin; i != end; /*i++*/) {
        uint8_t high = hex_detail::HEX_MAP[static_cast<uint8_t>(*i++)];
        if (high == 0xFF) return false;
        uint8_t low = hex_detail::HEX_MAP[static_cast<uint8_t>(*i++)];
        if (low == 0xFF) return false;
        *out = (high << 4) | low;
    }
    return true;
}

inline bool from_hex(const char *str, void *buf, size_t str_size) {
    return from_hex<const char *, uint8_t *>(str, str + str_size, reinterpret_cast<uint8_t  *>(buf));
}

inline bool from_hex(const std::string &str, void *buf) {
    return from_hex(str.begin(), str.end(), reinterpret_cast<uint8_t  *>(buf));
}

template<typename Container>
inline bool from_hex(const std::string &str, Container &c) {
    return from_hex(str.begin(), str.end(), std::back_inserter(c));
}

} // namespace fingera
