#include <fingera/hash/multiway_sha256.hpp>

#include <boost/test/unit_test.hpp>

#include <iostream>
#include <fingera/config.hpp>
#include <fingera/multiway_integer.hpp>
#include <fingera/hex.hpp>
#include <fingera/instrinsic/mi_sse2.hpp>
#include <fingera/instrinsic/mi_avx2.hpp>

BOOST_AUTO_TEST_SUITE(multiway_sha256_tests)

BOOST_AUTO_TEST_CASE(base) {
    using namespace fingera;

    uint8_t sha256_blocks[8 * 64] = {
        /////////////////////////////// '0' ///////////////////////////////
        // data
        0x30,
        // pad
        0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // length
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
        /////////////////////////////// '1' ///////////////////////////////
        // data 1
        0x31,
        // pad
        0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // length
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
        /////////////////////////////// '2' ///////////////////////////////
        // data 2
        0x32,
        // pad
        0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // length
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
        /////////////////////////////// '3' ///////////////////////////////
        // data
        0x33,
        // pad
        0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // length
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
        /////////////////////////////// '4' ///////////////////////////////
        // data
        0x34,
        // pad
        0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // length
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
        /////////////////////////////// '5' ///////////////////////////////
        // data
        0x35,
        // pad
        0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // length
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
        /////////////////////////////// '6' ///////////////////////////////
        // data
        0x36,
        // pad
        0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // length
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
        /////////////////////////////// '7' ///////////////////////////////
        // data
        0x37,
        // pad
        0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // length
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
    };
    uint8_t result[32 * 8] = {0};
    std::string hashes[] = {
        "5feceb66ffc86f38d952786c6d696c79c2dbc239dd4e91b46729d73a27fb57e9",
        "6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b",
        "d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab35",
        "4e07408562bedb8b60ce05c1decfe3ad16b72230967de01f640b7e4729b49fce",
        "4b227777d4dd1fc61c6f884f48641d02b4d121d3fd328cb08b5531fcacdabf8a",
        "ef2d127de37b942baad06145e54b0c619a1f22327b2ebbcfbec78f5564afe39d",
        "e7f6c011776e8db7cd330b54174fd76f7d0216b612387a5ffcfb81e6f0919683",
        "7902699be42c8a8e46fbbb4501726517e86b22c56a189f7625a6da49081b2451",
    };

    for (size_t i = 0; i < 8; i++) {
        memset(result, 0, sizeof(result));
        hash::multiway_sha256<multiway_integer<uint32_t, uint32_t>>::process_trunk(result, sha256_blocks + i * 64);
        BOOST_CHECK_EQUAL(to_hex(result, 32), hashes[i]);
        memset(result, 0, sizeof(result));
        hash::multiway_sha256<multiway_integer_slow<uint32_t, 1>>::process_trunk(result, sha256_blocks + i * 64);
        BOOST_CHECK_EQUAL(to_hex(result, 32), hashes[i]);
    }
    for (size_t i = 0; i < 4; i++) {
        memset(result, 0, sizeof(result));
        hash::multiway_sha256<multiway_integer<uint32_t, uint64_t>>::process_trunk(result, sha256_blocks + i * 64 * 2);
        BOOST_CHECK_EQUAL(to_hex(result, 32), hashes[i * 2]);
        BOOST_CHECK_EQUAL(to_hex(result + 32, 32), hashes[i * 2 + 1]);
        memset(result, 0, sizeof(result));
        hash::multiway_sha256<multiway_integer_slow<uint32_t, 2>>::process_trunk(result, sha256_blocks + i * 64 * 2);
        BOOST_CHECK_EQUAL(to_hex(result, 32), hashes[i * 2]);
        BOOST_CHECK_EQUAL(to_hex(result + 32, 32), hashes[i * 2 + 1]);
    }
    for (size_t i = 0; i < 2; i++) {
#if defined(FINGERA_USE_SSE2)
        memset(result, 0, sizeof(result));
        hash::multiway_sha256<instrinsic::mi_sse2>::process_trunk(result, sha256_blocks + i * 64 * 4);
        BOOST_CHECK_EQUAL(to_hex(result, 32), hashes[i * 4]);
        BOOST_CHECK_EQUAL(to_hex(result + 32 * 1, 32), hashes[i * 4 + 1]);
        BOOST_CHECK_EQUAL(to_hex(result + 32 * 2, 32), hashes[i * 4 + 2]);
        BOOST_CHECK_EQUAL(to_hex(result + 32 * 3, 32), hashes[i * 4 + 3]);
#endif
        memset(result, 0, sizeof(result));
        hash::multiway_sha256<multiway_integer_slow<uint32_t, 4>>::process_trunk(result, sha256_blocks + i * 64 * 4);
        BOOST_CHECK_EQUAL(to_hex(result, 32), hashes[i * 4]);
        BOOST_CHECK_EQUAL(to_hex(result + 32 * 1, 32), hashes[i * 4 + 1]);
        BOOST_CHECK_EQUAL(to_hex(result + 32 * 2, 32), hashes[i * 4 + 2]);
        BOOST_CHECK_EQUAL(to_hex(result + 32 * 3, 32), hashes[i * 4 + 3]);
    }

#if defined(FINGERA_USE_AVX2)
    memset(result, 0, sizeof(result));
    hash::multiway_sha256<instrinsic::mi_avx2>::process_trunk(result, sha256_blocks);
    for (size_t i = 0; i < 8; i++) {
        BOOST_CHECK_EQUAL(to_hex(result + 32 * i, 32), hashes[i]);
    }
#endif
}

BOOST_AUTO_TEST_SUITE_END()